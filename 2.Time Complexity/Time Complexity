# ğŸ“˜ **Time & Space Complexity â€” DSA Notes (Day 2)**

---

## â±ï¸ What is Time Complexity?

Time Complexity tells us **how fast an algorithm runs** as the input size grows.

> â— **Time Complexity â‰  Actual Runtime**
> Itâ€™s about **growth rate**, not stopwatch time.

---

## âš”ï¸ Linear Search vs Binary Search

### ğŸ” **Linear Search**

* âœ… Works on: **Unsorted Arrays**
* ğŸ§  Best Case: Element at 1st index â†’ `O(1)`
* ğŸ” Average Case: Element at n/2 â†’ `O(n/2)`
* âŒ Worst Case: Element not found â†’ `O(n)`
* â³ **Time Complexity:** `O(n)`

---

### ğŸ§  **Binary Search**

* âœ… Works on: **Sorted Arrays**
* ğŸ§  Best Case: Middle element â†’ `O(1)`
* ğŸ” Avg/Worst Case: Divide by 2 each step â†’ `O(log n)`
* â³ **Time Complexity:** `O(log n)`

> ğŸ” For n = 100
>
> * Linear Search: 100 steps
> * Binary Search: \~7 steps
>   â†’ Binary Search is **way more efficient** for large datasets!

---

## ğŸ“ˆ Big O Notation

Used to express **worst-case** time complexity.

| Big O      | Name         | Example Use                 |
| ---------- | ------------ | --------------------------- |
| O(1)       | Constant     | Accessing an array index    |
| O(log n)   | Logarithmic  | Binary Search               |
| O(n)       | Linear       | Linear Search               |
| O(n log n) | Linearithmic | Merge Sort, Quick Sort      |
| O(nÂ²)      | Quadratic    | Nested Loops                |
| O(nÂ³)      | Cubic        | Triple Nested Loops         |
| O(2â¿)      | Exponential  | Recursive Fibonacci         |
| O(n!)      | Factorial    | Permutations (Backtracking) |

---

## ğŸ§® Code Examples of Time Complexities (in JavaScript-style syntax)

---

### âœ… **O(1) â€“ Constant Time**

```js
let value = arr[5];  // Direct access
```

---

### ğŸ” **O(n) â€“ Linear Time**

```js
for(let i = 0; i < n; i++) {
    // do something
}
```

---

### ğŸ”‚ **O(log n) â€“ Logarithmic Time** (Binary Search)

```js
function binarySearch(arr, key) {
    let low = 0, high = arr.length - 1;
    while (low <= high) {
        let mid = Math.floor((low + high) / 2);
        if (arr[mid] === key) return mid;
        else if (arr[mid] < key) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

---

### ğŸ”ğŸ” **O(nÂ²) â€“ Quadratic Time** (Nested Loop)

```js
for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
        // do something
    }
}
```

---

### ğŸ”â³ **O(n log n) â€“ Linearithmic Time**

```js
for(let i = 0; i < n; i++) {
    let temp = n;
    while (temp > 1) {
        temp = Math.floor(temp / 2);
        // do something
    }
}
```

---

### ğŸ”ğŸ”ğŸ” **O(nÂ³) â€“ Cubic Time** (Triple Loop)

```js
for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
        for(let k = 0; k < n; k++) {
            // do something
        }
    }
}
```

---

### ğŸ§¬ **O(2â¿) â€“ Exponential Time** (Recursive Fibonacci)

```js
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

---

### ğŸ² **O(n!) â€“ Factorial Time** (Permutations)

```js
function permute(str, l, r) {
    if (l === r) {
        console.log(str);
    } else {
        for (let i = l; i <= r; i++) {
            [str[l], str[i]] = [str[i], str[l]]; // swap
            permute(str, l + 1, r);
            [str[l], str[i]] = [str[i], str[l]]; // backtrack
        }
    }
}
```

---

## ğŸ’¾ What is Space Complexity?

Space Complexity = **Extra memory** used by the algorithm.

---

### ğŸ§  Examples:

| Code Action               | Space Complexity |
| ------------------------- | ---------------- |
| Access 5th element        | O(1)             |
| Variable for max value    | O(1)             |
| New array of size `n`     | O(n)             |
| 2D Matrix of size `n x n` | O(nÂ²)            |

---

## ğŸ“Š Time Complexity Chart Summary

```
O(1)     â†’ ğŸŸ¢ Excellent
O(log n) â†’ ğŸŸ¢ Great
O(n)     â†’ ğŸŸ¡ Okay
O(n log n) â†’ ğŸŸ¡ Efficient for sorting
O(nÂ²)    â†’ ğŸ”´ Avoid if n is large
O(nÂ³)    â†’ ğŸ”´ Inefficient
O(2â¿), O(n!) â†’ âŒ Brutal â€” only for small inputs
```

---

## ğŸ¯ Key Takeaway

> Choose the right algorithm by analyzing its time & space complexity.
> **Efficient logic beats brute force!**

---

