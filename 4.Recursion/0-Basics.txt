## ğŸ” What is Recursion?

A function that **calls itself** to solve smaller instances of the same problem.

---

## ğŸ”§ Key Components:

1. **Base Case** â€“ when to stop recursion
2. **Recursive Case** â€“ function calls itself with modified input

---

## ğŸ§  How It Works:

Each call is pushed onto the **call stack** â†’ once base case is hit, stack unwinds.

---

## ğŸ“¦ Example (Factorial):

```js
function factorial(n) {
  if (n === 0) return 1; // Base case
  return n * factorial(n - 1); // Recursive case
}
```

---

## âš ï¸ Common Mistakes:

- Missing base case â†’ causes **infinite recursion**
- Not reducing the problem â†’ leads to **stack overflow**

---

## âœ… When to Use:

- Problems that can be broken into smaller subproblems
- Examples:

  - Factorial, Fibonacci
  - Tree/Graph traversal (DFS)
  - Backtracking (e.g., N-Queens, permutations)

---

## ğŸ”„ Recursion vs Iteration:

- **Recursion** is elegant, closer to problem definition
- **Iteration** is often more memory-efficient

---

## ğŸ”§ Tip:

If recursion is too deep (stack overflow), consider:

- Using iteration
- Applying **tail recursion** (in languages that optimize it)
